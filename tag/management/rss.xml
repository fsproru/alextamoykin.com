<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>alextamoykin.com</title>
   
   <link>http://alextamoykin.com/</link>
   <description>Building world-class software, teams, and products.</description>
   <language>en-us</language>
   <managingEditor> Alex Tamoykin</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>How to Reduce Manual QA, Increase Product Quality and Iterate Faster</title>
	  <link>//how-to-reduce-manual-qa-increase-quality-of-your-product-and-iterate-faster</link>
	  <author>Alex Tamoykin</author>
	  <pubDate>2017-11-12T00:00:00-08:00</pubDate>
	  <guid>//how-to-reduce-manual-qa-increase-quality-of-your-product-and-iterate-faster</guid>
	  <description><![CDATA[
	     <p>Product development is a very complex task involving ideation, product and project management, design, software engineering and testing. As you develop more features, manually testing every feature becomes impossible over time. The number of bugs increases and the development cycle slows down. This post demonstrates how to automate your quality assurance efforts to increase the quality of your product and iterate faster.</p>

<h3 id="why-reduce-manual-qa">Why reduce manual QA</h3>
<p>Let’s take a look at a typical software development cycle with only manual QA.</p>

<p><img src="/assets/images/development_cycle_with_manual_qa.jpg" alt="Software Development Cycle with Manual QA" async="true" /></p>

<p>Let’s say you have two teams, a software development team, and a QA team. Software engineers only write application code, the QA team tests the developed product. Once a new release is developed under phase 1, the software goes to the QA team. The QA team executes manual tests by going through the user interface and making sure the product works right in phase 2. If a bug is found in phase 3, the QA team tells the development team how to reproduce the bug. Sometimes a product manager is involved to prioritize bug fixes to go in certain releases. As you can see, it’s a complex process involving communication between developers and QA engineers on a regular basis. In addition to it, there are only so many manual tests that a human can execute per day.</p>

<p><strong>Manual QA doesn’t scale well.</strong> As I mentioned previously, what happens after you develop more and more features, a number of manual tests increases and teams usually make one of the following decisions. They either hire more QA staff (which may be challenging for startups with limited capital) or execute fewer tests. Unfortunately, most of the companies I’ve seen go with the second approach which causes bugs, loss of customers, and lost revenue.</p>

<p>There is another way, have computers execute tests for you.</p>

<h3 id="what-are-automated-tests">What are automated tests</h3>
<p>When you write a piece of software, you want to make sure it works correctly. Let’s say, you implemented a login screen in your mobile app. After you’re done with your task, you may go ahead, stand up the app and try logging into the system. After you move on to the next feature, you test the next feature is a similar way. As you develop more features, you can’t possibly test all features you developed to date. It will simply take you too much time to test every feature manually every time you change the code. What ends up happening is that you break previously developed functionality without even realizing it.</p>

<p>That’s where automated tests come in. An automated test is a piece of code that executes your manual test. You write it once and execute it with one command any number of times you want. In the example of the login screen, you write a test that stands up the app and taps into a field with an invisible finger, enters some information and checks that the user is successfully logged in.</p>

<p><img src="/assets/images/development_cycle_with_automated_qa.jpg" alt="Software Development Cycle with Automated QA" async="true" /></p>

<p>As you can see from the following diagram, all 3 steps of software development happen during the same development phase. It involves fewer people, it lowers communication overhead, and increases quality (computers are more consitent at running tests than humans).</p>

<h3 id="how-to-automate-your-tests">How to automate your tests</h3>

<ul>
  <li>
    <h4 id="product-managers-to-provide-clear-requirements">Product Managers to provide clear requirements</h4>
    <p>Developing and trying to automate an undefined product is very expensive. If requirements constantly change, both, the application code and automated tests need to be constantly rewritten. In addition to it, it’s tough to identify the best testing strategy if you don’t know what kind of product you’re building. Make sure your product manager provides clear acceptance criteria for every user story.</p>
  </li>
  <li>
    <h4 id="engineers-write-unit-and-integration-tests">Engineers write unit and integration tests</h4>
    <p>The problem with a manual test is that you need to have a human executing it every single time which is expensive. If you automate your test, you spend a little more effort upfront by writing it. Then, you have your <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank">continuous integration</a> servers running tests for you as many times and as often as you would like.</p>
  </li>
  <li>
    <h4 id="dont-automate-every-single-thing">Don’t automate every single thing</h4>
    <p>It’s a delicate balance between what makes sense to automate and what doesn’t. You have to compare a time cost and a benefit. In some cases, an integration test gives you the most bang for the buck. In some cases, it’s easier to test an isolated piece of logic with a unit test instead.</p>
  </li>
  <li>
    <h4 id="qa-engineers-test-interactions-between-systems">QA engineers test interactions between systems</h4>
    <p>If your product consists of multiple systems (like a mobile front end, a web front end, multiple back-end services, etc), it’s important to test all pieces altogether. Software engineers make sure every system is functioning correctly. However, it doesn’t really matter if each piece works as expected if the system as a whole doesn’t work. Cross-functional tests are the toughest to write. Make sure you automate the tests you execute most often manually first to be more efficient.</p>
  </li>
</ul>

<h3 id="final-words">Final words</h3>
<p>Automated tests are a great way to increase quality and iterate faster. If you keep your tests healthy, you can ship your software to production at any time. It allows your business to move quicker, iterate and learn faster. Writing automated tests is an important skill for every software engineer. It takes some time to develop and it pays off big time. Every system is different. That’s why you need to constantly challenge yourself with writing fewer tests that cover more functionality.</p>

	  ]]></description>
	</item>

	<item>
	  <title>5 Rules of Managing Technical Debt. How to Keep Moving Fast Today and Tomorrow.</title>
	  <link>//5-rules-of-managing-technical-debt-how-to-keep-moving-fast-today-and-tomorrow</link>
	  <author>Alex Tamoykin</author>
	  <pubDate>2017-09-03T00:00:00-07:00</pubDate>
	  <guid>//5-rules-of-managing-technical-debt-how-to-keep-moving-fast-today-and-tomorrow</guid>
	  <description><![CDATA[
	     <p>If you’re a nontechnical person, you probably heard the terms like <a href="https://www.agilealliance.org/project-management-and-technical-debt/" target="_blank">technical debt</a>, refactoring, and a hack before. Knowing what is technical debt helps you work productively with software engineers. This post explains what technical debt is and how to manage it efficiently.</p>

<h3 id="what-is-technical-debt">What is Technical Debt</h3>
<p>Technical debt is similar to credit card debt. You can spend some extra money now with a credit card. If you won’t pay it back shortly, you’ll be charged interest. If you don’t pay it off for a long time, the amount you owe increases drastically. This decreases your credit score which is hard to recover from.</p>

<p>Taking on technical debt in software product development is very similar to it. In order to accomplish a certain feature faster in the short term, a developer can apply a hack. If the hack is not replaced with a well made out solution, the code around it decays over time. In addition to it, software is built on top of other software. We all use libraries and operating systems. Technologies change and the system needs maintenance updates as time goes by, even if there are no new features being developed. If maintenance updates are not addressed, it also increases your technical debt.</p>

<p><img src="/assets/images/credit_cards.jpg" alt="Credit Card Debt" /></p>

<h3 id="why-taking-on-more-technical-debt-slows-you-down">Why Taking on More Technical Debt Slows You Down</h3>
<p>As you apply more hacks, your future development gets slower, you have more bugs in the product, and you get closer to the point when you need to start over. I’ve seen several companies in the past abandoning and rewriting their entire application from scratch since they were not able to make meaningful progress anymore.</p>

<h3 id="how-to-manage-technical-debt">How to Manage Technical Debt</h3>

<h4 id="get-on-the-same-page-with-engineers-and-stakeholders">Get on the same page with engineers and stakeholders</h4>
<p>It’s crucially important for everyone on your engineering team and for stakeholders to understand the implications of endlessly taking on technical debt. Set up and maintain high code standards and high test coverage on your engineering team. Make sure that stakeholders understand the technical debt concept and how it affects speed and quality of the product. Aligning everyone’s expectations goes a long way.</p>

<h4 id="pay-it-off-right-after-you-introduced-it">Pay it off right after you introduced it</h4>
<p>Every system has technical debt. Sometimes we need to focus on short-term goals. In this case, it’s ok to introduce technical debt <em>if and only if</em> you can pay it off right after you introduced it. The companies that ignore this important fact and continue to what seems like “moving quickly” will eventually slow down to a halt.</p>

<h4 id="revisit-your-architecture-regularly">Revisit your architecture regularly</h4>
<p>What worked several months ago will not necessarily work now. Especially in startups where businesses grow and change fast, it’s important to revisit decisions made in the past. Take your time to <a href="/why-nothing-makes-me-happier-than-deleting-code">refactor (or better yet, delete) code that no longer makes sense</a> in order to accomplish the needs of today. Bring it up with your team as a part of your <a href="/why-throwing-more-features-at-the-product-doesnt-work">retrospectives</a> and make action items to make sure it gets done.</p>

<p><img src="/assets/images/make_it_rain.gif" alt="Make It Rain" /></p>

<h4 id="pay-off-big-debt-incrementally">Pay off big debt incrementally</h4>
<p>When we deal with legacy systems, it may be bigger than a task of one software engineer to refactor it. In this case, make a plan on how you want it to look and change it one piece at the time. It’s important to maintain the vision of what you want this legacy system to be at the end.</p>

<h4 id="leave-the-codebase-in-a-better-place-than-when-you-started">Leave the codebase in a better place than when you started</h4>
<p>I can’t emphasize it enough. All that matters if everyone makes incremental progress towards making the codebase better. It’s impractical to stop feature development to get rid of all technical debt. Maintaining the right balance between feature delivery and paying off technical debt is the key.</p>

<h3 id="final-words">Final Words</h3>
<p>Every system out there has technical debt. Managing it effectively is a skill that can be learned. Technical debt is a risk. It’s best to avoid risk and sometimes you have to take it. As long as the team is disciplined about paying it off, it’s ok. At the end of the days, we all want to ship quality product and managing technical debt is a part of it.</p>

<p><em>Photos are provided by <a href="https://www.flickr.com/photos/p_valdivieso/" target="_blank">p_valdivieso</a> and <a href="https://www.flickr.com/photos/smemon" target="_blank">smemon</a></em></p>

	  ]]></description>
	</item>

	<item>
	  <title>5 Steps To Hire Best Software Engineers. 0 to 100 real quick!</title>
	  <link>//5-steps-to-hire-best-software-engineers-0-to-100-real-quick</link>
	  <author>Alex Tamoykin</author>
	  <pubDate>2017-02-05T00:00:00-08:00</pubDate>
	  <guid>//5-steps-to-hire-best-software-engineers-0-to-100-real-quick</guid>
	  <description><![CDATA[
	     <div class="right-align">
<a target="_blank" href="https://www.amazon.com/gp/product/0812993012/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0812993012&amp;linkCode=as2&amp;tag=howtoprogramb-20&amp;linkId=2120756ab226e93d40edaaa7fb74a759"><img border="0" src="//ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;MarketPlace=US&amp;ASIN=0812993012&amp;ServiceVersion=20070822&amp;ID=AsinImage&amp;WS=1&amp;Format=_SL250_&amp;tag=howtoprogramb-20" /></a><img src="//ir-na.amazon-adsystem.com/e/ir?t=howtoprogramb-20&amp;l=am2&amp;o=1&amp;a=0812993012" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
</div>

<h3 id="why">Why</h3>
<p>Hiring is important. Your team is the most valuable asset of the company. Products come and go, markets and technologies change. The team is what makes a company a success! If you’re running a tech company, your software engineers are going to play a vital part in your success. This post explains how to hire best engineers.</p>

<blockquote>
  <p>If you give a good idea to a mediocre team, they will screw it up. If you give a mediocre idea to a brilliant team, they will either fix it or throw it away and come up with something better. - Ed Catmull. Co-Founder of Pixar and the author of <a href="https://www.amazon.com/gp/product/0812993012/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=howtoprogramb-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0812993012&amp;linkId=4f4cc7ef29a896fb2d82c61b4f0a582a" target="_blank">Creativity, Inc</a></p>
</blockquote>

<h3 id="sourcing-candidates">1. Sourcing candidates</h3>
<p>The first step, source a lot of candidates. Hiring pipeline is a funnel. There should be a lot of candidates at the very top of the funnel. Only the best engineers who are the right fit will get the offer. In my experience, from 10 engineers there is 1 decent engineer. Also, keep in mind that about 50% of candidates accept the offer. In order to find the right people, source a lot of candidates. Here are the places to look at:</p>

<ul>
  <li><strong>References.</strong> This is the most effective way to get candidates. If a person you trust recommends you an engineer whom he/she worked with before, you should contact this candidate as soon as possible. Great developers want to work with more great developers and this kind of candidates tend to fit well culturally.</li>
  <li><strong>LinkedIn.</strong> Look at some top developer profiles on LinkedIn. On each profile, there is usually a section called “People Also Viewed” with even more profiles. You can click on each of them and then, rinse, repeat. Reach out to developers asking for their interest. You never know who is looking or who is ready to move on.</li>
  <li><strong>Job Postings.</strong> Create a job posting on <a href="https://jobs.github.com/post#create" target="_blank">Github</a>, <a href="http://talent.stackoverflow.com/jobs/create?cw=1" target="_blank">StackOverflow</a> or <a href="https://angel.co/recruiting" target="_blank">Angel List</a>. Keep in mind, the market is hot, so make sure your posting looks attractive.</li>
</ul>

<h3 id="phone-screen">2. Phone screen</h3>
<p>Now that you got in touch with your prospective candidates, schedule a phone screen with them. You’ll have to do a lot of phone screens so it’s important to keep it efficient. I usually do a 45-minute call which is broken down into 3 parts:</p>

<ul>
  <li><strong>Ice-breaker.</strong> I tell about the opportunity and ask questions about the resume. Starting with a question like “How much do you know about the company X ?” can save you some time so you can focus on filling the gaps. Then I ask a couple of questions about the resume. The key here is to keep your questions focused. In this case, you can verify whether they really have the experience listed.</li>
  <li><strong>Simple coding exercise.</strong> I usually do interviews over a video chat like Google Hangout. I ask a candidate to share the screen and implement a simple coding challenge. The candidate is encouraged to ask questions and walk me through the implementation. This step is meant to be a conversation rather than coding in silence. Seeing a person code in real time reveals a lot of things like debugging skills, algorithm choices and communication skills.</li>
  <li><strong>Finishing questions.</strong> This is where high-level architecture or framework knowledge questions go. At the end of the interview, I answer questions the candidate has for me.</li>
</ul>

<h3 id="in-house-interview">3. In-house interview</h3>

<p><img src="/assets/images/job_interview_prank.gif" alt="Job interview prank" async="true" /></p>

<blockquote>
  <p>Be mindful about your and candidate’s time.</p>
</blockquote>

<p>Bring the candidate on-site to show them around the office and meet the team. Your team’s time is valuable, so is the candidate time. Some companies prefer to have a full day on-site interview. I usually keep it short with just two rounds of interviews with developers. Developers go in pairs. Make sure the team synced up before the interview and everybody knows which questions to answer. It’s important to probe for these things:</p>

<ul>
  <li><strong>Code quality.</strong> The most important thing is to figure out if they can write great quality code in a reasonable timeframe. It’s good to give a candidate a moderately complex problem and work with them on coding a solution. You want to make sure the candidate makes reasonable choices. It’s ok to make minor mistakes if they can see it and fix it. Keep in mind that the code you see during the interview will be the code you’ll see in your code base if the person gets hired.</li>
  <li><strong>Cultural fit.</strong> Would you want to work next to this person every day? Does the candidate communicate well? Do you like the person’s attitude? If you’re interviewing a person, these are the questions to ask yourself.</li>
</ul>

<blockquote>
  <p>Treat the candidate the same way you would like to be treated.</p>
</blockquote>

<p>Developer time is a finite resource. If it’s clear that the person is not a fit from the first pair of interviewers, tell the candidate so and stop the interview. Have you ever been in the interview where you didn’t hear anything back? It’s not fun to be in this situation so treat people the way you would like to be treated. Tell the candidate why it’s not the right fit and what they can improve. If you see the potential, tell the candidate that you would like to touch base in the next 6 to 12 months to see if the situation is improved. If you’re not comfortable delivering this feedback in person on the day of the interview then walk out the candidate and follow up the next day over the phone or email.</p>

<p>On the other end, if the candidate made it to the end of the in-house interview, communicate to the candidate that the interview is finished. Tell the candidate that you’ll get back to him/her in the next couple of days.</p>

<h3 id="references">4. References</h3>
<p>Request at least 3 references and call each of them. Ask them about their experience working with the candidate. Ask what the person is good at and what he/she needs to improve. Keep in mind that it will take time since people have their own schedules. It’s important to move quickly. If you’re super excited about the candidate you can make an offer contingent on a reference check.</p>

<h3 id="offer">5. Offer</h3>
<p>You should be excited about the candidate you would like to hire. Get all participants in the room, have each interviewer to write down their outcome. Each person’s outcome should be unaffected by anybody’s opinion. Go around the room where each person reveals the score with the reasoning behind it. If there is a consensus in the room, it’s a pretty easy decision to make. If you’re on the fence, it may be tempting to bring the candidate for another round for more information. From my experience, you don’t get more information after the in-house interview. Make a decision with the information you have. If you’re not sure, the answer is no.</p>

<p>Keep in mind, great software engineers are not on a job market for a long time. You have to move quick. After you know the outcome, communicate it to the candidate. If the answer is no, explain why politely. If the answer is yes, communicate it to the candidate and send the candidate an offer letter. Give a candidate some time to think and follow up on a decision. Good luck!</p>

<h3 id="final-words">Final words</h3>
<p>Hiring is a long play game. You should never hire people you don’t like. Even if you have a lot of work to do, it’s never worth it. Be patient and keep interviewing. Every person counts and hiring the right software engineer will greatly increase your chances of success!</p>

	  ]]></description>
	</item>


</channel>
</rss>
